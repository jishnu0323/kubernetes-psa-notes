<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3 doc-content"><p class="c2"><span class="c1">##################################</span></p><p class="c2"><span class="c1">Docker &amp; Kubernetes Overview</span></p><p class="c2"><span class="c1">##################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">What is Docker?</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Docker is a free and open-source containerization software that allows you to package applications along with their dependencies into a single unit called a Docker Image. This image can run on any system that has Docker installed, making deployment easy and consistent across different environments.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Why use Docker?</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#9989; Portability &ndash; Run the same application on any machine, regardless of OS configuration.</span></p><p class="c2"><span class="c1">&#9989; Dependency Management &ndash; Ensures that all required software (e.g., libraries, databases, and runtimes) is included within the image.</span></p><p class="c2"><span class="c1">&#9989; Fast Deployment &ndash; No need to manually install dependencies every time you set up a new environment.</span></p><p class="c2"><span class="c1">&#9989; Resource Efficiency &ndash; Uses fewer resources compared to traditional virtual machines.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">######################</span></p><p class="c2"><span class="c1">How Docker Works?</span></p><p class="c2"><span class="c1">######################</span></p><p class="c2"><span class="c1">Create a Docker Image &ndash; Package the app code + dependencies into a lightweight container image.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Run the Docker Container &ndash; Deploy this image as a container using the docker run command.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Execute Anywhere &ndash; The same image runs on any machine with Docker installed.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Once the image is built, it can run on any machine without requiring additional software setup.</span></p><p class="c2"><span class="c1">____________________________________________________________________________________________________________________</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">###############################################</span></p><p class="c2"><span class="c1">Kubernetes (Container Orchestration Software)</span></p><p class="c2"><span class="c1">###############################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">What is Kubernetes?</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes (K8s) is a free and open-source orchestration tool developed by Google to manage containerized applications.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128161; Orchestration = Managing multiple containers efficiently</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes automates key tasks like:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">1. Creating, starting, and stopping containers.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2. Scaling up/down based on demand.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">3. Handling failures automatically.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">######################</span></p><p class="c2"><span class="c1">Why use Kubernetes?</span></p><p class="c2"><span class="c1">######################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#9989; Orchestration &ndash; Efficiently manages multiple containers across a cluster of machines.</span></p><p class="c2"><span class="c1">&#9989; Self-Healing &ndash; If a container crashes, Kubernetes automatically replaces it.</span></p><p class="c2"><span class="c1">&#9989; Load Balancing &ndash; Distributes traffic across multiple containers to avoid overloading.</span></p><p class="c2"><span class="c1">&#9989; Auto Scaling &ndash; Increases or decreases the number of running containers based on traffic load.</span></p><p class="c2"><span class="c1">&#9989; Automated Deployments &ndash; Supports CI/CD for rolling updates and version control.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes Advantages (Detailed Explanation)</span></p><p class="c2"><span class="c1">1) Orchestration &ndash; Managing Containers</span></p><p class="c2"><span class="c1">Kubernetes helps manage multiple Docker containers across different machines (nodes) efficiently.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128313; Instead of running docker run manually for each container, Kubernetes automates deployment.</span></p><p class="c2"><span class="c1">&#128313; It ensures that all containers are running smoothly and adjusts their status as needed.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Note: Kubernetes ensures all these containers are running, healthy, and communicating with each other properly.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2) Self-Healing &ndash; Automatic Recovery</span></p><p class="c2"><span class="c1">If a container crashes due to an error or system failure, Kubernetes automatically restarts a new instance.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128204; Example:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">A web server container (Apache, Nginx) stops unexpectedly.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes detects the failure and starts a new container to replace it.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Users never notice downtime.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">3) Load Balancing &ndash; Distributes Traffic Efficiently</span></p><p class="c2"><span class="c1">Kubernetes distributes incoming user requests across multiple containers to avoid overloading any single instance.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128204; Example:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">A shopping website experiences high traffic during a sale.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes ensures that requests are evenly distributed across available backend servers.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Prevents server crashes and ensures smooth performance.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">4) Auto Scaling &ndash; Adjusting Resources Dynamically</span></p><p class="c2"><span class="c1">Kubernetes can increase or decrease the number of containers automatically based on traffic load.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128204; Example:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">If website traffic increases, Kubernetes adds more containers to handle the load.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">If traffic reduces, Kubernetes removes extra containers to save resources.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Works similarly to cloud-based Auto Scaling Groups (ASG).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Conclusion</span></p><p class="c2"><span class="c1">&#128640; Docker simplifies packaging applications into portable containers.</span></p><p class="c2"><span class="c1">&#128640; Kubernetes ensures these containers are orchestrated, scalable, and reliable.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Together, Docker &amp; Kubernetes enable modern cloud-native application deployment&mdash;making applications highly available, efficient, and automated.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#########################################################</span></p><p class="c2"><span class="c1">Kubernetes (K8s) Architecture - Explained in Detail</span></p><p class="c2"><span class="c1">#########################################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 655.00px; height: 323.92px;"><img alt="" src="images/image1.png" style="width: 655.00px; height: 323.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">1) Control Plane (Master Node/Control Node)</span></p><p class="c2"><span class="c1">-&gt; The control plane is responsible for managing the Kubernetes cluster. It includes the following components:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">1. API Server: Receives requests from kubectl and manages cluster operations.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2. Scheduler: Identifies pending tasks in ETCD and assigns them to worker nodes.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">3. Controller Manager: Ensures the cluster&rsquo;s desired state matches the actual state.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">4. ETCD: A distributed key-value store that acts as Kubernetes&#39; internal database.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2) Worker Nodes (Slave Nodes)</span></p><p class="c2"><span class="c1">-&gt; Worker nodes run application workloads. They include the following components:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">1. Kubelet: A node agent that communicates with the control plane and manages containers.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2. Kube Proxy: Manages networking and ensures communication within the cluster.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">3. Docker Engine: Runs and manages containerized applications.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">4. Pod: The smallest deployable unit in Kubernetes, housing one or more containers.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">5. Container: Runs inside a Pod and contains the application code.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">####################################</span></p><p class="c2"><span class="c1">Explanation k8S working</span></p><p class="c2"><span class="c1">####################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step 1: To deploy an application, we interact with the control plane using the kubectl CLI.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step 2: The API Server receives the request and stores it in ETCD with a pending status.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step 3: The Scheduler identifies an available worker node to execute the task, using Kubelet for node management.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step 4: The Kubelet ensures the worker node is running the assigned workload.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step 5: The Kube Proxy manages networking for seamless cluster communication.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step 6: The Controller Manager continuously monitors the cluster to ensure tasks run correctly.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">##########</span></p><p class="c2"><span class="c1">Note:</span></p><p class="c2"><span class="c1">##########</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; A cluster in Kubernetes (K8s) refers to a group of servers (nodes) that work together to run containerized applications. It consists of:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">a. Control Plane (Master Node) &ndash; Manages and controls the cluster.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">b. Worker Nodes (Slave Nodes) &ndash; Run application workloads inside containers.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">###################################</span></p><p class="c2"><span class="c1">Kubernetes (K8s) Cluster Setup</span></p><p class="c2"><span class="c1">####################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">A Kubernetes Cluster is a group of servers working together to run containerized applications. It can be set up in two main ways:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">A Kubernetes Cluster = Control Plane + Worker Nodes + Pods + Resources + Networking + Storage</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">1) Self-Managed Cluster </span></p><p class="c2"><span class="c1">In this setup, we manually install and manage Kubernetes on our own infrastructure.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">a) MiniKube (Single Node)</span></p><p class="c2"><span class="c1">-&gt; Runs a single-node cluster on a local machine.</span></p><p class="c2"><span class="c1">-&gt; Best for learning and practicing Kubernetes concepts.</span></p><p class="c2"><span class="c1">-&gt; Not suitable for production as it lacks high availability and scalability.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">b) Kubeadm (Multi-Node)</span></p><p class="c2"><span class="c1">-&gt; A tool for setting up a multi-node cluster manually.</span></p><p class="c2"><span class="c1">-&gt; Requires configuring the control plane, worker nodes, and networking.</span></p><p class="c2"><span class="c1">-&gt; Gives full control over the cluster but requires deep Kubernetes expertise.</span></p><p class="c2"><span class="c1">-&gt; Used for on-premise or customized Kubernetes deployments.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2) Cloud Provider-Managed Cluster (Pre-configured, ready-to-use)</span></p><p class="c2"><span class="c1">Cloud providers offer fully managed Kubernetes services, where they handle cluster maintenance, updates, and availability.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">a) AWS EKS (Elastic Kubernetes Service)</span></p><p class="c2"><span class="c1">-&gt; A managed Kubernetes service on Amazon Web Services.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">b) Azure AKS (Azure Kubernetes Service)</span></p><p class="c2"><span class="c1">-&gt; Microsoft Azure&rsquo;s managed Kubernetes offering.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">c) GCP GKE (Google Kubernetes Engine)</span></p><p class="c2"><span class="c1">-&gt; Google Cloud&rsquo;s fully managed Kubernetes solution.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#########################</span></p><p class="c2"><span class="c1">MiniKube Setup</span></p><p class="c2"><span class="c1">#######################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-1 : Setup Linux VM</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Login into AWS Cloud account</span></p><p class="c2"><span class="c1">Create Linux VM with Ubuntu AMI - t2.medium</span></p><p class="c2"><span class="c1">Select Storage as 50 GB or more with 2 vCPU required minimum(Default is 8 GB only for Linux)</span></p><p class="c2"><span class="c1">Create Linux VM and connect to it using SSH Client</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-2 : Install Docker In Ubuntu VM</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">sudo apt update</span></p><p class="c2"><span class="c1">curl -fsSL get.docker.com | /bin/bash</span></p><p class="c2"><span class="c1">sudo usermod -aG docker ubuntu </span></p><p class="c2"><span class="c1">exit</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-3 : Updating system packages before installing Minikube dependencies</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">sudo apt update</span></p><p class="c2"><span class="c1">sudo apt install -y curl wget apt-transport-https</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-4 : Installing Minikube</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span></p><p class="c2"><span class="c1">sudo install minikube-linux-amd64 /usr/local/bin/minikube</span></p><p class="c2"><span class="c1">minikube version</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-5 : Install Kubectl (Kubernetes Client)</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</span></p><p class="c2"><span class="c1">chmod +x kubectl</span></p><p class="c2"><span class="c1">sudo mv kubectl /usr/local/bin/</span></p><p class="c2"><span class="c1">kubectl version -o yaml</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-6 : Start MiniKube Server</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">minikube start &mdash; driver=docker</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-7 : Check MiniKube status</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">minikube status</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-8 : Access K8S Cluster</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl cluster-info</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Step-9 : Access K8S Nodes</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl get nodes</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ Setup Completed $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#####################################</span></p><p class="c2"><span class="c1">&#128640; What is a POD in Kubernetes?</span></p><p class="c2"><span class="c1">#####################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#9989; Key Concepts Explained:</span></p><p class="c2"><span class="c1">-----------------------------</span></p><p class="c2"><span class="c1">1. If you deploy an app, it will ultimately run inside one or more Pods. It is a building block to run app that we deploy in K8S</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2. &quot;Applications will be deployed as PODS in k8s.&quot;</span></p><p class="c2"><span class="c1">Your app (e.g., a Spring Boot API) will be containerized using Docker. This container will then be wrapped inside a Pod and deployed on the cluster.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">3. &quot;To create PODS we will use Docker images.&quot;</span></p><p class="c2"><span class="c1">A Pod runs one or more containers (usually one), and each container uses a Docker image. You can build a Docker image of your app and then deploy it inside a Pod.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">4. &quot;To create PODS we will use Manifest YML file.&quot;</span></p><p class="c2"><span class="c1">A YAML manifest file defines the configuration for the Pod (or other resources like Deployments).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">It includes:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">a. The name of the Pod</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">b. The image to use</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">c. Ports to expose</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">c. Environment variables, etc.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">5. &quot;Create multiple PODS.&quot;</span></p><p class="c2"><span class="c1">The same image (e.g., myapp:latest) can be used to create many Pods. This is how you scale your application&mdash;running multiple copies (Pods) to handle more traffic.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">6. &quot;If we run application with multiple pods then Load Balancing can be performed resulting in 99.9% uptime of the application.&quot;</span></p><p class="c2"><span class="c1">High Availability: If one Pod crashes, others are still running, so your app stays available.Load Balancing: Kubernetes distributes traffic across Pods using a Service (like a load balancer).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">7. &quot;PODS count will be increased and decreased based on the demand (scalability).&quot;</span></p><p class="c2"><span class="c1">Kubernetes supports auto-scaling. You can scale Pods manually or automatically using a Horizontal Pod Autoscaler (HPA). Based on CPU/memory usage or custom metrics, Kubernetes will increase/decrease the number of Pods.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">###############################</span></p><p class="c2"><span class="c1">&#128640; Kubernetes Services</span></p><p class="c2"><span class="c1">###############################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; A Kubernetes Service is used to expose a group of Pods so that they can be accessed reliably. Since Pods can be created and destroyed at any time (with changing IPs), a Service gives them a stable network identity.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---------------------------</span></p><p class="c2"><span class="c1">&#129517; Why Do We Use Services?</span></p><p class="c2"><span class="c1">---------------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; Pods are short-lived and can crash or restart.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; Each time a Pod is created, it gets a new IP address.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; Directly accessing Pods via IP is not reliable.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; A Service gives a static IP to a group of Pods.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---------------------------------</span></p><p class="c2"><span class="c1">&#127760; Types of Kubernetes Services</span></p><p class="c2"><span class="c1">---------------------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes offers different types of services depending on how and where you want to expose your Pods:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128313; 1. ClusterIP (Default)</span></p><p class="c2"><span class="c1">&#128312; 2. NodePort</span></p><p class="c2"><span class="c1">&#128313; 3. LoadBalancer</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-------------------------------------------------------</span></p><p class="c2"><span class="c1">&#128272; ClusterIP Service (Internal Access Only)</span></p><p class="c2"><span class="c1">-------------------------------------------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128204; Key Points:</span></p><p class="c2"><span class="c1">-&gt; Pods are short-lived objects; if one crashes, Kubernetes replaces it with a new Pod.</span></p><p class="c2"><span class="c1">-&gt; Every new Pod gets a different IP address.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Note: &#128721; Never rely on Pod IPs to access an application.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; A ClusterIP Service groups multiple Pods &nbsp;and assigns them a single static IP.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; This static IP allows other components inside the cluster to access the group of Pods reliably, even when individual Pods change.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---------------------</span></p><p class="c2"><span class="c1">&#128683; Access Scope:</span></p><p class="c2"><span class="c1">---------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; Only accessible within the Kubernetes cluster.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; Not reachable from the outside world (internet or external clients).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">----------------</span></p><p class="c2"><span class="c1">&#128161; Use Case:</span></p><p class="c2"><span class="c1">----------------</span></p><p class="c2"><span class="c1">-&gt; Internal services such as databases, backend APIs, authentication services, etc.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Example: You don&rsquo;t want to expose a database Pod to the internet, so you use a ClusterIP service to allow access only from other internal Pods.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">----------------------------------------------------</span></p><p class="c2"><span class="c1">&#127760; What is a NodePort Service in Kubernetes?</span></p><p class="c2"><span class="c1">----------------------------------------------------</span></p><p class="c2"><span class="c1">-&gt; A NodePort service is a type of Kubernetes Service that exposes your Pods outside the cluster using a port on each worker node (called a &quot;NodePort&quot;).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#129517; Why Use NodePort?</span></p><p class="c2"><span class="c1">------------------------------------</span></p><p class="c2"><span class="c1">By default, Pods and ClusterIP services are only accessible within the cluster.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">NodePort makes them accessible externally by opening a static port (from 30000 to 32767) on each worker node.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">It allows you to access your application using:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">http://&lt;NodeIP&gt;:&lt;NodePort&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Note: Here all traffic is routed to one worker node. Means load balancing cannot happen here.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-----------------------------------------------------</span></p><p class="c2"><span class="c1">&#127760; What is a LoadBalancer Service in Kubernetes?</span></p><p class="c2"><span class="c1">-----------------------------------------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; It not only provides external access to your app but also handles automatic traffic distribution across the backend Pods running on different worker nodes.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">##############################################</span></p><p class="c2"><span class="c1">&#128196; What is a Kubernetes Manifest YAML?</span></p><p class="c2"><span class="c1">##############################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; Think of it as an instruction manual for Kubernetes to create and manage resources.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#129521; Main Sections of a Manifest YAML</span></p><p class="c2"><span class="c1">-----------------------------------</span></p><p class="c2"><span class="c1">Here are the 4 main parts:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">apiVersion: &lt;version-number&gt; &nbsp; # API version to use</span></p><p class="c2"><span class="c1">kind: &lt;resource-type&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Type of resource (Pod, Service, Deployment, etc.)</span></p><p class="c2"><span class="c1">metadata: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Metadata like name, labels</span></p><p class="c2"><span class="c1">spec: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Specification of what the resource should do</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-------------------------------</span></p><p class="c2"><span class="c1">&#129514; Example: Pod Manifest YAML</span></p><p class="c2"><span class="c1">Let&rsquo;s look at a simple Pod definition:</span></p><p class="c2"><span class="c1">-------------------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: Pod</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp; name: testpod</span></p><p class="c2"><span class="c1">&nbsp; labels:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; app: dempapp</span></p><p class="c2"><span class="c1">spec:</span></p><p class="c2"><span class="c1">&nbsp; containers:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; - name: test</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; image: psait/pankajsiracademy:latest</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; ports:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; - containerPort: 9090</span></p><p class="c2"><span class="c1">...</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-------------------</span></p><p class="c2"><span class="c1">Explanation</span></p><p class="c2"><span class="c1">-------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">Tells Kubernetes to use version v1 of the API.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Since you are creating a Pod, this is the correct API version.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kind: Pod</span></p><p class="c2"><span class="c1">Defines the type of resource you want to create.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">In this case, it&rsquo;s a Pod, which is the smallest and simplest unit in Kubernetes.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">Metadata gives Kubernetes basic info about your Pod.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">name: testpod</span></p><p class="c2"><span class="c1">This is the name of your Pod.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">You&rsquo;ll use this name to check logs or status (e.g., kubectl get pod testpod).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">labels:</span></p><p class="c2"><span class="c1">Labels are key-value pairs to categorize and group Kubernetes objects.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">app: dempapp is a label to help identify this Pod as part of the &quot;dempapp&quot; application.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">spec:</span></p><p class="c2"><span class="c1">This section defines what&rsquo;s inside the Pod.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">containers:</span></p><p class="c2"><span class="c1">A Pod can contain one or more containers. You&#39;re defining one container here.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">- name: test</span></p><p class="c2"><span class="c1">This is the name of the container inside the Pod (not the Pod itself).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">image: psait/pankajsiracademy:latest</span></p><p class="c2"><span class="c1">This is the Docker image used to create the container.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">It will pull the latest version of psait/pankajsiracademy from Docker Hub or another registry.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#9888;&#65039; Make sure the image exists and is accessible (public or with correct credentials).</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">ports:</span></p><p class="c2"><span class="c1">This tells Kubernetes the container is listening on port 8080 inside the Pod.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">containerPort: 8080</span></p><p class="c2"><span class="c1">This is the internal port your application is running on.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Kubernetes can use this for things like service routing, health checks, etc.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#############</span></p><p class="c2"><span class="c1">Commands:</span></p><p class="c2"><span class="c1">######################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Note: Save above content in .yml file</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># execute manifest yml</span></p><p class="c2"><span class="c1">kubectl apply -f &lt;manifest-yml-file&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># check pods</span></p><p class="c2"><span class="c1">kubectl get pods</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># check pod logs</span></p><p class="c2"><span class="c1">kubectl logs &lt;pod-name&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># Describe pods</span></p><p class="c2"><span class="c1">kubectl describe pod &lt;pod-name&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># get pod logs</span></p><p class="c2"><span class="c1">kubectl logs &lt;pod-name&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---------------------------------------------</span></p><p class="c2"><span class="c1">K8s Service Manifest YAML (for your Pod)</span></p><p class="c2"><span class="c1">------------------------------------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: Service</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp; name: testpod-service</span></p><p class="c2"><span class="c1">spec:</span></p><p class="c2"><span class="c1">&nbsp; type: NodePort</span></p><p class="c2"><span class="c1">&nbsp; selector:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; app: dempapp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This must match the Pod&#39;s label</span></p><p class="c2"><span class="c1">&nbsp; ports:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; - port: 80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Exposed port for external access</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; targetPort: 9090 &nbsp; &nbsp; # Port on which the app is running inside the container</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; nodePort: 30080 &nbsp; &nbsp; &nbsp;# External port exposed on each node</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128161; Explanation:</span></p><p class="c2"><span class="c1">----------------------</span></p><p class="c2"><span class="c1">name: testpod-service &ndash; The name of the service.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">type: NodePort &ndash; Exposes the Pod outside the cluster.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">selector.app: dempapp &ndash; This matches the label of your Pod, so the service knows which Pod(s) to route to.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">port: 80 &ndash; The port used when calling the service.Port 80 is the default port for HTTP traffic</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">You&#39;re using a web server like Nginx, Apache, or similar.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">targetPort: 8080 &ndash; The port your container app actually listens on.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">nodePort: 30080 &ndash; External port accessible via http://&lt;NodeIP&gt;:30080</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Commands</span></p><p class="c2"><span class="c1">___________</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># &#128269; Check existing services</span></p><p class="c2"><span class="c1">kubectl get svc</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># &#128230; Create the service using the YAML</span></p><p class="c2"><span class="c1">kubectl apply -f testpod-service.yml</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># &#128257; Verify that the service is created</span></p><p class="c2"><span class="c1">kubectl get svc</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># &#128682; Open service in browser (Minikube only)</span></p><p class="c2"><span class="c1">minikube service testpod-service</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># Test</span></p><p class="c2"><span class="c1">#Get minikube ip address</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Test this in same local network</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">curl http://&lt;mini-kube-ip&gt;:3080/</span></p><p class="c2"><span class="c1">curl http://192.168.49.2:30080/</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Part&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Meaning</span></p><p class="c2"><span class="c1">curl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A tool to make HTTP requests from the command line. It&#39;s often used to test whether a URL is reachable and what it returns.</span></p><p class="c2"><span class="c1">http://192.168.49.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the IP address of the Minikube VM. It&#39;s the entry point into your Kubernetes cluster from your host machine. You found this IP using minikube ip.</span></p><p class="c2"><span class="c1">:30080&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the NodePort exposed by your Kubernetes service (testpod-service). It forwards external requests to the internal Pod&rsquo;s port (8080 in your case).</span></p><p class="c2"><span class="c1">/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the path of the URL. Since it&#39;s just a /, it hits the root endpoint of your Spring Boot app.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#################################################</span></p><p class="c2"><span class="c1">note: How to delete pod and services</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl delete pod testpod</span></p><p class="c2"><span class="c1">kubectl delete svc testpod-service</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl apply -f pod-01.yml</span></p><p class="c2"><span class="c1">kubectl apply -f service-01.yml</span></p><p class="c2"><span class="c1">############################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#############</span></p><p class="c2"><span class="c1">Stop complete minikube</span></p><p class="c2"><span class="c1">#################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; minikube stop</span></p><p class="c2"><span class="c1">-&gt; minikube delete</span></p><p class="c2"><span class="c1">-&gt; minikube status</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#####################</span></p><p class="c2"><span class="c1">To see all resources running</span></p><p class="c2"><span class="c1">####################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; kubectl get all</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">########################</span></p><p class="c2"><span class="c1">To delete all resources use</span></p><p class="c2"><span class="c1">########################</span></p><p class="c2"><span class="c1">-&gt; kubectl delete all --all</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#######################################</span></p><p class="c2"><span class="c1">What are name spaces in k8s?</span></p><p class="c2"><span class="c1">#######################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; They help logically group and isolate resources. Just like how we create folders to isolate our work in computers.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">------------------</span></p><p class="c2"><span class="c1">Example:</span></p><p class="c2"><span class="c1">-----------------</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">database-ns = all database-related stuff</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">backend-ns = for backend applications</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Note: If we donot specifiy name space they k8S will automatically provide default name - space</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#####################</span></p><p class="c2"><span class="c1">Commands</span></p><p class="c2"><span class="c1">###################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">list all name spaces</span></p><p class="c2"><span class="c1">----------------------</span></p><p class="c2"><span class="c1">-&gt; kubectl get ns</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">list all pods in given name space</span></p><p class="c2"><span class="c1">-----------------------------------</span></p><p class="c2"><span class="c1">-&gt; kubectl get pod -n &lt;name-space&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#############################################</span></p><p class="c2"><span class="c1">How to create name space in k8s</span></p><p class="c2"><span class="c1">#############################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">1. Using kubectl command-</span></p><p class="c2"><span class="c1">kubectl create namespace backend-ns</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">2.using manifest yml file </span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: Namespace</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp;name: backend-ns</span></p><p class="c2"><span class="c1">... </span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># execute manifest yml</span></p><p class="c2"><span class="c1">kubeclt apply -f &lt;yml-file-name&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1"># get all resources belongs to backend-ns namespace</span></p><p class="c2"><span class="c1">kubectl get all -n backend-ns</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#get all pods in kube-system</span></p><p class="c2"><span class="c1">kubectly get pods -n kube-system</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#get all worker nodes</span></p><p class="c2"><span class="c1">kubectl get nodes</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#delete name space - All resource related to that will be deleted</span></p><p class="c2"><span class="c1">kubectl delete ns backend-ns</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#Open tunnel</span></p><p class="c2"><span class="c1">minikube service &lt;service-name&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">############################</span></p><p class="c2"><span class="c1">Namespace with POD with Service creation yml file</span></p><p class="c2"><span class="c1">##############################</span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: Namespace</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp;name: backend-ns</span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: Pod</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp; name: testpod</span></p><p class="c2"><span class="c1">&nbsp; namespace: backend-ns</span></p><p class="c2"><span class="c1">&nbsp; labels:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; app: dempapp</span></p><p class="c2"><span class="c1">spec:</span></p><p class="c2"><span class="c1">&nbsp; containers:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; - name: test</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; image: psait/pankajsiracademy:latest</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; ports:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; - containerPort: 9090</span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: Service</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp; name: testpod-service</span></p><p class="c2"><span class="c1">&nbsp; namespace: backend-ns</span></p><p class="c2"><span class="c1">spec:</span></p><p class="c2"><span class="c1">&nbsp; type: NodePort</span></p><p class="c2"><span class="c1">&nbsp; selector:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; app: dempapp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This must match the Pod&#39;s label</span></p><p class="c2"><span class="c1">&nbsp; ports:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; - port: 80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Exposed port for external access</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; targetPort: 9090 &nbsp; &nbsp; # Port on which the app is running inside the container</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; nodePort: 30080 &nbsp; &nbsp; &nbsp;# External port exposed on each node</span></p><p class="c2"><span class="c1">...</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#########################################</span></p><p class="c2"><span class="c1">k8S Resources</span></p><p class="c2"><span class="c1">########################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; When you create a Pod directly using kind: Pod, Kubernetes does not manage its lifecycle &mdash; if it crashes or is deleted, it&#39;s gone forever unless recreated manually.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; K8S resources manages POD lifecycle</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">-&gt; To let Kubernetes manage, restart, and scale Pods, we use higher-level controllers like the ones you listed.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#128257; 1) ReplicationController (RC)</span></p><p class="c2"><span class="c1">&#128257; 2) ReplicaSet (RS)</span></p><p class="c2"><span class="c1">&#128640; 3) Deployment</span></p><p class="c2"><span class="c1">&#128752; 4) DaemonSet</span></p><p class="c2"><span class="c1">&#128190; 5) StatefulSet</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">#####################################</span></p><p class="c2"><span class="c1">&#128230; What is ReplicationController (RC)?</span></p><p class="c2"><span class="c1">A Kubernetes resource used to manage the lifecycle of Pods.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Ensures a specified number of Pods are always running.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">Provides self-healing &mdash; if a Pod crashes or is deleted, RC will recreate it.</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">manifest yml file</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">---</span></p><p class="c2"><span class="c1">apiVersion: v1</span></p><p class="c2"><span class="c1">kind: ReplicationController</span></p><p class="c2"><span class="c1">metadata:</span></p><p class="c2"><span class="c1">&nbsp;name: webapp</span></p><p class="c2"><span class="c1">spec:</span></p><p class="c2"><span class="c1">&nbsp;replicas: 3</span></p><p class="c2"><span class="c1">&nbsp;selector:</span></p><p class="c2"><span class="c1">&nbsp; app: dempapp</span></p><p class="c2"><span class="c1">&nbsp;template:</span></p><p class="c2"><span class="c1">&nbsp; metadata:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp;name: testpod</span></p><p class="c2"><span class="c1">&nbsp; &nbsp;labels: </span></p><p class="c2"><span class="c1">&nbsp; &nbsp; app: dempapp</span></p><p class="c2"><span class="c1">&nbsp; spec:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp;containers:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; - name: webappcontainer</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; image: psait/pankajsiracademy:latest</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; ports:</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; - containerPort: 9090</span></p><p class="c2"><span class="c1">...</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl apply -f rc.yml</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">########################################################</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl get all</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl get pods</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl delete pod &lt;pod-name&gt;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl get pods</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl scale rc dempapp --replicas=5</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">kubectl scale rc dempapp --replicas=1 &nbsp;Explain in short</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">##############################################</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p></body></html>